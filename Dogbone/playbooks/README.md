# Provisioning EC2 instances

This folder contains the setup that allows us to create new EC2 instances or update the provisioning on existing instances using Ansible.  Provisioning is all the steps that need to be done infrequently (mostly only when a new box is created or when something significant changes in the way boxes are set up) and require root priviledges on the box.  To just deploy the application to a running instance, please use `fab -H ubuntu@instance.beagle.ai deploy:committish` in the root of this repository, which does not require root or most of the extra secrets that a full provisioning requires.

To use this provisioning setup you will need Ansible at least 2.0 and also Fabric installed locally.
The local machine will also need python's "boto" package installed.

In ubuntu that's the python-boto package.
boto3 is a different thing, and is not compatible with the library we use.

## Set up authentication

### AWS Config
Like most tools that deal with AWS, this provisioning setup expects that you have `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` set in your environment when you run it.  You can generate access keys using your AWS account dashboard.

Since the python `boto` package has been installed the AWS credentials can be stored in the `~/.aws/credentials` (for a Mac) file, which means it doesn't have to be set in the environment i.e.
```
[default]
aws_access_key_id = <AWS_ACCESS_KEY_ID>
aws_secret_access_key = <AWS_SECRET_ACCESS_KEY>
```
However, different regions require different credentials, these can be saved as:
```
[default]
aws_access_key_id = <AWS_ACCESS_KEY_ID>
aws_secret_access_key = <AWS_SECRET_ACCESS_KEY>

[<profile_name_1>]
aws_access_key_id = <AWS_ACCESS_KEY_ID>
aws_secret_access_key = <AWS_SECRET_ACCESS_KEY>

[<profile_name_2>]
aws_access_key_id = <AWS_ACCESS_KEY_ID>
aws_secret_access_key = <AWS_SECRET_ACCESS_KEY>
```

### Connecting to AWS Instance
You also need to have a working SSH public key in the form of `~/.ssh/id_beagle_*.pub`. If you don't already have it, you can use `ssh-keygen` to generate them and there plenty of online tutorials to document this process.

Run `ssh-add ~/.ssh/id_beagle_*` to add the private key to the ssh session. This key is used by ansible to ssh directly into the server.


### Adding github repo
An SSH key with access to Github (probably your default key) needs to be in the ssh agent.  If you do not have this set up normally, just run `ssh-add ~/.ssh/id_*.pub`

## Set up secrets locally

Ansible requires some secrets when provisioning boxes, which are not checked into this repository.  Get these from someone who has them:

- secrets.yml
- roles/nginx/files/beagle.ai.key

The structure of secrets.yml is (where null is replaced by the actual key):
```
sendgrid_password: null
AWS_ACCESS_KEY_ID: null # (Mandatory)
AWS_SECRET_ACCESS_KEY: null # (Mandatory)
INTERCOM_APP_ID: null
INTERCOM_DEV_APP_ID: null
INTERCOM_API_KEY: null
INTERCOM_DEV_API_KEY: null
SESSION_SECRET: null # (Mandatory)

SLACK_WEBHOOK: null
SLACK_USERNAME: null
AMI_ID: null
SECURITY_GROUP_NAME: beagle_public_services

env: null # (Mandatory, if not passed in with the arguments)
branch: null # (Mandatory, if not passed in with the arguments)
instance_type: t2.small

region: null # (Mandatory, if not passed in with the arguments)
region_name: null # (Mandatory)
db_password: null # (Mandatory)
```

## To Create a New Instance
After having set the required variable in the ansible secrets.yml file e.g. region, branch etc. Run the following command assuming the aws credentions is the default provile:

```
$ ansible-playbook ec2.yml -e 'env=dev'
```

If the aws credentials is not the default setting, the command will be modified to:
```
$ AWS_PROFILE=<profile_name> ansible-playbook ec2.yml -e 'env=dev'
```

This will create a new instance with environment and name tags set to `dev` the region and git branch defined in `secrets.yml`.  It will also create an RDS instance in the same region, with an autogenerated root password, as well as an Elasticache instance in the same region.
The naming convention for the different instances is `<region_name>-<env>`, where `<region_name>` is set in `globals.yml`

The combination of `<region_name>` and `<env>` should not exceed 20 characters, or you might get naming errors.


### Potential issues.
- The setup assumes that the `AMI (amazon machine image)` has been defined in secrets.yml, if the `AMI_ID` doesn't exist you can find a suitable one in aws public images. The suggested `AMI` is `ubuntu 14.04 Virtualization type = HVM`.

## To Re-Provision an Existing Instance

If any of the instance, RDS, or Elasticache already exist, they will be used and re-provisioned instead of creating new ones.  In this case, you do not need to specify any of `SLACK_WEBHOOK`, `SLACK_USERNAME`, or `db_password`.

You can also give the `--skip-tags deploy` option to `ansible-playbook` to skip the fab deploy on later runs.
This tends to make the deploy faster, and also doesn't redeploy the code unnecessarily if you're changing something else about the box.

## To Add or Remove Developer Access to Instances

Add or remove SSH public keys in `roles/developer_access/files/` and re-provision the instances you want to change access on.

## prod\_envs

To determine if an instance should run Django in DEBUG mode and if Intercom should use the "dev" API keys, the provisioning system checks the provided `env` value against those in globals.yml under "prod\_envs".  If you create a new production-style environment key, you will want to add it to this file.

## Ansible Extra Vars

Some "extra vars" have already been seen in the examples above.  They are passed in `key=value` format to the `-e` switch passed to `ansible-playbook`.  The extra vars recognised by this provisioning at the time of writing are documented here for completeness:

- **SLACK\_USERNAME** Slack username to use for logging
- **SLACK\_WEBHOOK** Secret Slack webhook to use for logging
- **branch** Git branch to checkout and track
- **db\_password** Root password for pre-existing RDS instance
- **env** sets the `environment` EC2 tag on the instance (so it can be found for re-provisioning) and also configures which RDS and Elasticache instance to use, and the hostname of the box (which is expected to be `env.beagle.ai`)
- **instance\_type** Type of EC2 instance to use (default: t2.small)
- **instances** Number of instances to run of this type (default: 1, NOTE: some more work, such as adding a load balancer, would be needed to support counts higher than 1)
- **region** AWS region to look for / create instances in
